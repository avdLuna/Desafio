{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf600
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fswiss\fcharset0 Helvetica-Oblique;\f2\fswiss\fcharset0 Helvetica-Bold;
\f3\fswiss\fcharset0 Helvetica-BoldOblique;}
{\colortbl;\red255\green255\blue255;\red85\green142\blue40;\red0\green0\blue0;\red0\green0\blue0;
\red255\green255\blue255;\red85\green142\blue40;}
{\*\expandedcolortbl;;\cssrgb\c39975\c61335\c20601;\cssrgb\c0\c0\c0;\csgray\c0\c0;
\csgray\c100000;\cssrgb\c39975\c61335\c20601;}
\paperw11900\paperh16840\margl1440\margr1440\vieww25100\viewh19880\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs28 \cf0 1. Baixar o JSON\
	1.1. Entender o JSON\
		1.1.1.  
\f1\i postsData.data
\f0\i0  \'97> Local onde ficam os posts\
\
2. ElasticSearch\
	2.1. Baixar e executar elasticsearch\
		2.1.1. Executar 
\f1\i ./elasticsearch
\f0\i0  em 
\f1\i /bin
\f0\i0 \
		2.1.2. Testar um 
\f1\i get 
\f0\i0 para 
\f1\i localhost:9200 
\f0\i0 \'97>
\f2\b \cf2  OK
\f0\b0 \cf0 \
	2.2. Importar JSON para elasticsearch\
		2.2.1. Transformar JSON em NDJSON \'97> 
\f3\i\b \cf3 \cb4 \expnd0\expndtw0\kerning0
cat test.json | jq -c '.[]' > testNDJSON.json
\f2\i0 \

\f0\b0 		2.2.2. Adicionar as linhas de \'edndex antes de cada post \'97>
\f1\i  
\f3\b \cb5 \{"index": \{"_index": "your_index", "_type": "your_type", "_id": "975463711"\}\}
\f2\i0 \

\f0\b0 		2.2.3 Subir os dados para ElasticSearch \'97>
\f1\i  
\f3\b curl -s -H "Content-Type: application/json" -XPOST localhost:9200/posts/docs/_bulk --data-binary "@postsFormatted.json"\

\f1\b0 		
\f0\i0 2.2.4 Testar \'97>
\f1\i  http://localhost:9200/posts/_search?q="peppa" 
\f0\i0 \'97> 
\f2\b \cf2 OK\

\f0\b0 \cf3 \
3. API e Design\
	3.1. Utilizar 
\f1\i Springboot
\f0\i0  \'97> Familiaridade e Consist\'eancia\
	3.2. Posts ser\'e3o compostos de
\f1\i  content
\f0\i0 , 
\f1\i service
\f0\i0  e 
\f1\i hashtags
\f0\i0  \'97> Por quest\'f5es de mem\'f3ria (Se fosse colocar todos os atributos que n\'e3o iriam ser utilizado, gastaria mais) e desempenho (menos 												                      coisa pra procurar). Keep it simple\
	3.3. As buscas ser\'e3o feitas pelo 
\f1\i content
\f0\i0  do post, pois todos possuem o campo 
\f1\i content
\f0\i0 .\
	3.4. Vers\'e3o do elasticsearch do springboot suportada \'e9 at\'e9 6.4.3. Estava usando 7.3 e regredi para  a 6.4 \'97> 
\f2\b \cf6 OK
\f0\b0 \cf3 \
	3.5. Fazer a API funcionar\
		3.5.1. Criar 
\f1\i Model 
\f0\i0 \'97> Possui um 
\f1\i ID
\f0\i0 , 
\f1\i Service
\f0\i0 ,
\f1\i Content
\f0\i0  e 
\f1\i Hashtags
\f0\i0 \
		3.5.2. Criar 
\f1\i Repository
\f0\i0  \'97> Extends 
\f1\i ES repository
\f0\i0 \
		3.5.3. Criar 
\f1\i Controller
\f0\i0  \'97> Pega do 
\f1\i service
\f0\i0  e retorna um 
\f1\i response entity
\f0\i0 \
		3.5.4 Criar 
\f1\i Service
\f0\i0 \
			   3.5.4.1. Filtrar as postagens que n\'e3o possuem conte\'fado e/ou n\'e3o d\'e3o match com a string e/ou n\'e3o possuem hashtags\
			   3.5.4.2. Criar m\'e9todo
\f1\i  contains
\f0\i0  para dar match exatamente com a palavra, sen\'e3o o usu\'e1rio poderia colocar a palavra \'93conheci\'94e daria Match com \'93desconhecido\'94 utilizando 
\f1\i contains 					  
\f0\i0 convencional de java\
			   3.5.4.3. Colocar todas as hashtags em uma lista\
			   3.5.4.4. Ordeno as hashtags por quantidade em uma lista\
			   3.5.4.5. Retorno as top 10 hashtags \'97> 
\f2\b \cf6 OK
\f0\b0 \cf3 \
\cf0 \cb1 \kerning1\expnd0\expndtw0 \

\fs24 \
\
\
}